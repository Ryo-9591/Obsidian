２レベルまでネストできる
GROUP BYで返るやつにMAX(AVG())のように
# COUNT関数
## COUNT( * )
表の行数を数える
## COUNT(dep_id)
dep_id列がNULL以外の数を返す
## COUNT(DISTINCT dep_id)
dep_idがNULL以外で重複を除いた数を返す
# MAX/MIN関数
## 例①：日時データにMAX,MIN関数を使用する場合
`SELECT` 
  `MAX(hire_date) AS 最新入社日,`
  `MIN(hire_date) AS 最古入社日`
`FROM` 
  `employees;`
→時間が新しいほど大きい
## 例②：文字データにMAX,MINを使用する場合
`SELECT` 
  `MAX(first_name) AS 最後の名前,`
  `MIN(first_name) AS 最初の名前`
`FROM` 
  `employees;`
→文字コードに依存するA～Z
※NULL値は除外して評価する
# GROUP BY

`SELECT AVG(・・・) FROM employees;`
→単一行変える

`SELECT AVG(・・・) FROM employees GROUP BY job_id;`
→GROUP BYでくくられたグループの数分値が返る

`SELECT MIN(AVG(salary)) FROM employees GROUP BY job_id;`
→GROUP BYでくくられた数分AVGが出て、その中のMINが返る
## GROUP BYを使用する例
`SELECT job_id , AVG(MIN(salary)) FROM employees GROUP BY job_id;`
→エラー(salaryがレベル2で１行返るのに対してjob_idは１レベルで複数行変えるのでエラーになる)

`SELECT department_id , job_id , AVG(salary) FROM employees GROUP BY job_id , department_id;`
→正常(レベルが合う)
# HAVING

## ①エラーパターン

`SELECT COUNT(department_id)` 
`FROM employees` 
`WHERE commission_pct  IS NOT NULL AND count(department_id)>4` 
`GROUP BY department_id;`  

→==commission_pct  IS NOT NULL==を評価して同時に==count(department_id)>4==の評価もする
→でもこの時点では「COUNT」はまだ存在していない（`GROUP BY`すら始まっていない）から 
→ エラーになる。

## ②正常パターン

`SELECT COUNT(department_id)` 
`FROM employees` 
`WHERE commission_pct  IS NOT NULL` 
`GROUP BY department_id` 
`HAVING count(department_id) >4;`  

・WHERE句 → 集計前に「commission_pctがNULLでない行だけ残す」
・GROUP BY → department_idごとにグループ化
・HAVING → 集計後に「そのグループの件数が5件以上」のグループだけ残す

## ③エラーパターン

`SELECT job_id, COUNT(department_id)` 
`FROM employees` 
`WHERE commission pct IS NOT NULL` 
`GROUP BY department_id` 
`HAVING count(*)>4;`

→job_idは集計関数に入っていないのでエラーになる
→==GROUP BY を使う場合のみ==非集計カラムは GROUP BY に含める必要がある

# GROUP BY句を使用するときのWHERE
GROUP BYが実行される前に絞り込みを実行できる
→HAVINGはGROUP BYの後に実行

集計ファンクションを使用することができない
→HAVINGは使用可能